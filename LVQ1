#!/bin/python3

import argparse
import pprint
import math

# Main function. This is the main entry-point into the algorithm

def main():
	parse_args()
	parse_data_file()
	pp = pprint.PrettyPrinter(indent=4)
	initialize_weights()
	pp.pprint(weight_matrix)
	train()
	pp.pprint(weight_matrix)

args = {}
flags = []
data_set = []
learning_rate = 1
pattern_length = 0
weight_matrix = []

def fatalError(msg):
	print()
	print("Error: " + msg)
	print()
	exit()

def parse_args():
	global args
	parser = argparse.ArgumentParser()
	parser.add_argument("data", help="The input set to cluster from.")
	parser.add_argument("clusters", help="The number of clusters to create.", type=int)
	parser.add_argument("output", help="The file to write the output to.")
	parser.add_argument("test", help="The file to test the centroid vectors on.")
	parser.add_argument("algorithm", help="The algorithm to use.", type=int)
	args = parser.parse_args()

def add_entry(line):
	line = line.strip()
	if line != "":
		data_set.append(list(map(lambda x : float(x), line.split("\t"))))

def parse_data_file():
	global pattern_length
	file = open(args.data)
	for line in file:
		add_entry(line)
	file.close()
	pattern_length = len(data_set[0])
	for pattern in data_set:
		if len(pattern) != pattern_length:
			fatalError("Mismatch between pattern lengths in data set.")

def initialize_weights():
	global weight_matrix
	print("Initializing matrix with " + str(args.clusters) + " x " + str(pattern_length))
	weight_matrix = [[ 0 for x in range(pattern_length)] for y in range(args.clusters)]

def euclid_dist(from_vector, to_vector):
	total = 0
	for x in range(pattern_length):
		total += math.pow(from_vector[x] - to_vector[x], 2)
	return math.sqrt(total)

def coerce_vector(input_vector, to_vector):
	for x in range(len(input_vector)):
		input_vector[x] = input_vector[x] - learning_rate*(input_vector[x] - to_vector[x]);
	return input_vector

def train():
	for entry in data_set:
		smallest_distance = math.inf
		smallest_distance_index = -1
		for x in range(len(weight_matrix)):
			current_dist = euclid_dist(entry, weight_matrix[x])
			if current_dist < smallest_distance:
				smallest_distance = current_dist
				smallest_distance_index = x
		weight_matrix[smallest_distance_index] = coerce_vector(weight_matrix[smallest_distance_index], entry)

if __name__ == "__main__":
	main()
